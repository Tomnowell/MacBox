//
//  VMRuntimeManager.swift
//  MacBox
//
//  Created by Tom on 2025/06/09.
//

@preconcurrency import Virtualization
import Foundation
import os.log

class VMDelegate: NSObject, VZVirtualMachineDelegate {
    private let vmID: UUID
    
    init(vmID: UUID) {
        self.vmID = vmID
    }
    
    // Called when the virtual machine stops due to an error.
    func virtualMachine(_ virtualMachine: VZVirtualMachine, didStopWithError error: Error) {
        print("VM \(vmID) did stop with error: \(error.localizedDescription)")
    }
    
    // Called when the guest OS inside the virtual machine stops.
    func guestDidStop(_ virtualMachine: VZVirtualMachine) {
        print("Guest inside VM \(vmID) did stop.")
    }
}

@MainActor
final class VMRuntimeManager: ObservableObject {
    static let shared = VMRuntimeManager()

    @Published private(set) var runningVMs: [UUID: VZVirtualMachine] = [:]

    private var vmDelegates: [UUID: VMDelegate] = [:]
    
    private var installationObservers: [UUID: NSKeyValueObservation] = [:]
    private var stateObservers: [UUID: NSKeyValueObservation] = [:]

    private init() {
        printRunningVMs()
    }

    func launchVM(from config: VMConfig) async throws {
        let (restoreImage, restoreImageURL) = try await VMInstaller.downloadLatest()
        if let most = restoreImage.mostFeaturefulSupportedConfiguration {
            print("Restore image hardware model supports minCPU=\(most.minimumSupportedCPUCount) minMem=\(most.minimumSupportedMemorySize)B")
        } else {
            print("Restore image missing mostFeaturefulSupportedConfiguration (unexpected)")
        }

        // Decide early if this is a fresh install (blank + no marker)
        // Determine per-VM disk path (mirrors builder logic: inside VM root directory)
        let prospectiveBootURL: URL = {
            if let p = config.bootDiskImagePath { return URL(fileURLWithPath: p) }
            let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
            let vmDir = appSupport.appendingPathComponent("MacBox", isDirectory: true)
                .appendingPathComponent("VMs", isDirectory: true)
                .appendingPathComponent(config.id.uuidString, isDirectory: true)
            try? FileManager.default.createDirectory(at: vmDir, withIntermediateDirectories: true)
            return vmDir.appendingPathComponent("Disk.img")
        }()
    let blank = (try? isDiskBlank(prospectiveBootURL)) ?? true
    let freshInstallMarker = blank && !installationMarkerExists(for: prospectiveBootURL)
    // Force fresh install for all new VMs to prevent DFU state errors
    
    // Only treat as fresh install if disk is truly blank and no installation marker exists
    let builderFresh = freshInstallMarker

    let configuration = try await VZConfigurationBuilder.build(from: config, restoreImage: restoreImage, freshInstall: builderFresh)
    print("Built configuration (freshInstall=\(builderFresh), blankDisk=\(blank)) for VM id=\(config.id)")
    let vm = VZVirtualMachine(configuration: configuration)
    // vm already created above

        // Assign delegate and retain it
        let delegate = VMDelegate(vmID: config.id)
        vm.delegate = delegate
        vmDelegates[config.id] = delegate

        runningVMs[config.id] = vm

        // Determine boot disk path (duplicate logic from builder for safety)
    let bootDiskURL = prospectiveBootURL

    let needsInstallation = freshInstallMarker
        if needsInstallation {
            print("Detected blank disk – beginning macOS installation instead of direct start.")
            installMacOS(on: vm, vmID: config.id, restoreImageURL: restoreImageURL, bootDiskURL: bootDiskURL)
            return
        }

        // Normal start path (already installed)
    try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            vm.start { result in
                switch result {
                case .success:
                    print("VM '\(config.name)' started.")
                    print("VM state after start: \(vm.state.rawValue)")
            continuation.resume(returning: ())
                case .failure(let error):
                    print("Failed to start VM '\(config.name)': \(error)")
                    self.runningVMs.removeValue(forKey: config.id)
                    self.vmDelegates.removeValue(forKey: config.id)
                    continuation.resume(throwing: error)
                }
            }
        }

        printRunningVMs()
        print("VM state: \(vm.state)")
        print("Can request stop: \(vm.canRequestStop)")
        print("Graphics Devices: \(String(describing: vm.graphicsDevices))")
    }

    func stopVM(id: UUID, completion: @escaping (Result<Void, Error>) -> Void) {
        guard let vm = runningVMs[id] else {
            completion(.failure(NSError(domain: "VMRuntimeManager", code: 404, userInfo: [NSLocalizedDescriptionKey: "VM not found."])))
            return
        }

        // Check if VM is already stopped
        if vm.state == .stopped {
            self.runningVMs.removeValue(forKey: id)
            self.vmDelegates.removeValue(forKey: id)
            completion(.success(()))
            return
        }

        vm.stop { error in
            DispatchQueue.main.async { [weak self] in
                guard let self else { return }
                if let error = error {
                    print("Failed to stop VM: \(error)")
                    completion(.failure(error))
                } else {
                    print("VM stopped successfully.")
                    self.runningVMs.removeValue(forKey: id)
                    self.vmDelegates.removeValue(forKey: id)
                    completion(.success(()))
                }
            }
        }
    }

    func isRunning(id: UUID) -> Bool {
        runningVMs[id] != nil
    }
    
    func virtualMachine(for id: UUID) -> VZVirtualMachine? {
        runningVMs[id]
    }
    
    func printRunningVMs() {
        if runningVMs.isEmpty {
            print("No VMs are currently running.")
        } else {
            print("Running VMs:")
            for (id, vm) in runningVMs {
                print("- ID: \(id), State: \(vm.state)")
            }
        }
    }
    
    // MARK: - Installation Flow Helpers
    private func isDiskBlank(_ url: URL) throws -> Bool {
        let fd = open(url.path, O_RDONLY)
        if fd < 0 { throw NSError(domain: "VMRuntimeManager", code: Int(errno), userInfo: [NSLocalizedDescriptionKey: "Unable to open disk for blank check: \(url.path) errno=\(errno)"]) }
        defer { close(fd) }
        var buffer = [UInt8](repeating: 0, count: 4096)
        let readCount = buffer.withUnsafeMutableBytes { read(fd, $0.baseAddress!, $0.count) }
        if readCount <= 0 { return true }
        let nonZero = buffer.prefix(readCount).first { $0 != 0 }
        return nonZero == nil
    }

    private func installationMarkerURL(for diskURL: URL) -> URL {
        diskURL.appendingPathExtension("installed")
    }
    private func installationMarkerExists(for diskURL: URL) -> Bool {
        FileManager.default.fileExists(atPath: installationMarkerURL(for: diskURL).path)
    }
    private func writeInstallationMarker(for diskURL: URL) {
        let marker = installationMarkerURL(for: diskURL)
        try? "installed".data(using: .utf8)?.write(to: marker)
    }

    private func installMacOS(on vm: VZVirtualMachine, vmID: UUID, restoreImageURL: URL, bootDiskURL: URL, attempt: Int = 1) {
        print("Starting macOS installation for VM \(vmID)")
        // Observe VM state transitions early
        stateObservers[vmID] = vm.observe(\.state, options: [.initial, .new]) { vmObserved, _ in
            print("[VM \(vmID)] State -> \(vmObserved.state.rawValue)")
        }
    // Use URL-based initializer (current SDK) – we already validated the image object
    let installer = VZMacOSInstaller(virtualMachine: vm, restoringFromImageAt: restoreImageURL)
        installationObservers[vmID] = installer.progress.observe(\.fractionCompleted, options: [.initial, .new]) { progress, _ in
            let pct = progress.fractionCompleted * 100
            print("[VM \(vmID)] Installation progress: \(String(format: "%.2f", pct))%")
        }
        installer.install { result in
            Task { @MainActor in
                switch result {
                case .success:
                    print("macOS installation succeeded for VM \(vmID)")
                    self.writeInstallationMarker(for: bootDiskURL)
                case .failure(let error):
                    print("macOS installation failed (attempt \(attempt)) for VM \(vmID): \(self.detailedErrorString(error))")
                    self.dumpFirstSectors(of: bootDiskURL, vmID: vmID)
                    // Extra diagnostic: check if disk header mutated at all (size, mod date already logged by builder)
                    if let attrs = try? FileManager.default.attributesOfItem(atPath: bootDiskURL.path) {
                        print("[VM \(vmID)] Post-failure disk attrs: \(attrs)")
                    }
                    if attempt < 3, self.isDFUStateError(error) {
                        print("Encountered DFU state; retrying installation attempt \(attempt + 1) after brief delay...")
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak self] in
                            guard let self else { return }
                            if let retryVM = self.runningVMs[vmID] {
                                self.installMacOS(on: retryVM, vmID: vmID, restoreImageURL: restoreImageURL, bootDiskURL: bootDiskURL, attempt: attempt + 1)
                            } else {
                                print("[VM \(vmID)] VM no longer present for retry")
                            }
                        }
                    } else if self.isUserDataFormatError(error) {
                        print("[VM \(vmID)] Detected 'User data is not supported in this image format' – will attempt one-time disk recreation then retry.")
                        do {
                            try FileManager.default.removeItem(at: bootDiskURL)
                            // Recreate disk with same size but without zero pre-write beyond first sector (minimal header) to test hypothesis
                            let size = UInt64(50) * 1024 * 1024 * 1024 // fallback 50GB; could infer from config but we lack it here
                            let fd = open(bootDiskURL.path, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR)
                            if fd >= 0 {
                                _ = ftruncate(fd, off_t(size))
                                close(fd)
                                print("[VM \(vmID)] Recreated raw disk without pre-zero for format retry")
                                if let retryVM = self.runningVMs[vmID] {
                                    self.installMacOS(on: retryVM, vmID: vmID, restoreImageURL: restoreImageURL, bootDiskURL: bootDiskURL, attempt: attempt + 1)
                                } else {
                                    print("[VM \(vmID)] VM no longer present after disk recreation")
                                }
                            } else {
                                print("[VM \(vmID)] Failed to recreate disk for retry errno=\(errno)")
                            }
                        } catch {
                            print("[VM \(vmID)] Failed disk recreation: \(error)")
                        }
                    }
                }
            }
        }
    }

    private func isDFUStateError(_ error: Error) -> Bool {
        let ns = error as NSError
        if ns.domain == "VZErrorDomain" || ns.domain.contains("MobileRestore") {
            if ns.localizedDescription.contains("DFU") { return true }
            if let underlying = ns.userInfo[NSUnderlyingErrorKey] as? NSError, underlying.localizedDescription.contains("DFU") { return true }
        }
        return false
    }

    private func detailedErrorString(_ error: Error) -> String {
        var lines: [String] = []
        func append(_ e: Error, depth: Int) {
            let ns = e as NSError
            let indent = String(repeating: "  ", count: depth)
            lines.append("\(indent)- domain=\(ns.domain) code=\(ns.code) desc=\(ns.localizedDescription)")
            if let underlying = ns.userInfo[NSUnderlyingErrorKey] as? Error { append(underlying, depth: depth+1) }
            if let debug = ns.userInfo["NSDebugDescription"] as? String { lines.append("\(indent)  debug=\(debug)") }
            if let vi = ns.userInfo["DIErrorVerboseInfo"] { lines.append("\(indent)  verbose=\(vi)") }
        }
        append(error, depth: 0)
        return lines.joined(separator: "\n")
    }

    private func dumpFirstSectors(of url: URL, vmID: UUID) {
        let fd = open(url.path, O_RDONLY)
        guard fd >= 0 else { print("[VM \(vmID)] Unable to open disk for sector dump errno=\(errno)"); return }
        defer { close(fd) }
        let bytes = 4096
        var buffer = [UInt8](repeating: 0, count: bytes)
        let readBytes = read(fd, &buffer, bytes)
        guard readBytes > 0 else { print("[VM \(vmID)] No bytes read from disk (readBytes=\(readBytes))"); return }
        let hex = buffer.prefix(readBytes).enumerated().map { i,b -> String in
            let prefix = (i % 16 == 0) ? String(format: "\n%04X: ", i) : ""
            return prefix + String(format: "%02X ", b)
        }.joined()
        print("[VM \(vmID)] First \(readBytes) bytes of disk dump:\n\(hex)\n")
    }
    
    private func isUserDataFormatError(_ error: Error) -> Bool {
        let ns = error as NSError
        if ns.localizedDescription.contains("User data is not supported in this image format") { return true }
        if let underlying = ns.userInfo[NSUnderlyingErrorKey] as? NSError, underlying.localizedDescription.contains("User data is not supported in this image format") { return true }
        return false
    }
    
}

